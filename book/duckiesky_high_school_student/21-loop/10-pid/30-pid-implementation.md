# Implementation of PID {#loop-pid-implementation status=ready}

### Altitude PID in Simulation

In this part of the project, you will be implementing a PID controller for a simulated drone that can only move in one dimension, the vertical dimension.  You can control the speed the motors spin on the drone, which sets the thrust being generated by the propellers. In this system, the process variable is the drone's altitude, the setpoint is the desired altitude, and the error is the distance in meters between the setpoint and the drone's altitude. The output of the control function is a [PWM (pulse-width modulation)](https://en.wikipedia.org/wiki/Pulse-width_modulation)
value between 1100 and 1900, which is sent to the flight controller to
set the drone's throttle.

To run the simulation, you need to use the vnc server. You can find the installation link [here](https://docs.duckietown.org/daffy/opmanual_sky/out/build_materials_excluded.html). 

Run `sudo vncserver`. 

With bash, navigate to the file named <i>drone_simulator</i>, which is located within the scripts folder of pidrone_pkg-master folder.  

You should implement the discretized version of the PID control function in <i>student_pid_class.py</i>:

$$ u(t) = K_pe(t_k) + K_i\sum_{i=0}^k e(t_i)\Delta t + K_d\frac{e(t_k)-e(t_{k-1})}{\Delta t} + K $$  

$$ K_p, K_i, K_d, K = Constants \; and \; Offset \; Term $$    

$$ e(t_k) = Error \; at \; Time \; t_k $$    

$$ \Delta t = Time \; Elapsed \; from \; Previous \; Iteration $$  

Notice that there is an extra offset term $K$ added to the control function. This is the base PWM value/throttle command before the three control terms are applied to correct the error in the system.

To tune your PID, set the parameters ($K_p, K_i, K_d, K$) in <i>z_pid.yaml</i>.  

To test your PID, run `python sim.py` on your base station or a department computer but not on your drone, since it requires a graphical user interface to visualize the output. The PID class in <i>student_pid_class.py</i> will automatically be used to control the simulated drone. The _up_ and _down_ arrow keys will change the setpoint, and _r_ resets the simulation.  

You will need _numpy_, _matplotlib_, and _yaml_ to run the simulation. To install these dependencies, run `pip install numpy matplotlib pyyaml`.  
 

## Problem 1:  Implement an Idealized PID

**Exercises**

  1. Implement the step method to return the constant $K$. At what value of
  $K$ does the drone takeoff? What could happen if $K$ were set too high on a real drone? Set $K$ to 1300 for the remainder of the questions.
  2. Implement the P term. What happens when the absolute value of $K_p$ is very large? What happens when its absolute value is very small? Can you tune the P term to stop oscillations? Why or why not?  
  3. Implement the D term. Set $K_p$ to zero. What happens when $K_d$ is 50? 500? 5000?  
  4. Now tune $K_p$ and $K_d$ so that the drone comes to a steady hover. Describe the trade-off as you change the ratio of $K_p$ to $K_d$. Can the drone stabilize at its target (zero steady-state error)? Why or why not?  
  5. Implement the I term and observe the difference between PD and PID control. What role does the I term play in this system? What happens when $K_p$ and $K_d$ are set to zero?  
  6. Implement the reset method and test its behavior. If implemented incorrectly, what problems can you anticipate reset causing?  
  7. Finally, tune the constants in your PID controller to the best of your abilities. When the setpoint is moving, the drone should chase the setpoint very closely. When the setpoint is still, the drone should converge exactly at the setpoint and not oscillate. Report your tuning values.

## Problem 2: Tuning a PID with Latency

Now, we introduce latency!  Run the simulation as `python sim.py -l 6` to
introduce 24 milliseconds of latency (six steps of latency running at
25 hz).  

**Exercises**

  1. Tune the constants in your PID controller to the best of your abilities. The drone should chase the setpoint very closely, but will converge more slowly when the setpoint is still. Report your tuning values.  
  2. Compare your tuning values to the values you obtained in problem 1.  
  3. Explain the effect of latency on each control term.  

## Problem 3: Tuning a PID with Latency, Noise, and Drag

In the most realistic mode, you will tune a controller with latency,
noise, and a drag coefficient.  You can do this with the command line
arguments `python sim.py -l 3 -n 0.5 -d 0.02` to be most realistic to
real-world flight.

**Exercises**

  1. Tune with these arguments to be as good as possible. Report your tuning values.  
  2. Compare your tuning values to the values from problems 1 and 2.  

Run `python sim.py -h` to see the other simulator parameters. We
encourage you to experiment with those and observe their
effects on your controller.


### Tuning 1D Controls: Part 1: Planar Tuning 

In this portion of the project, you will be tuning the low rate integral terms of the PID controllers that we've provided.

## Trimming your Drone
Due to differences in the weight distribution and other factors that cause asymmetries, the drone will tend to initially drift in a particular direction. In order to tune your altitude PID, the planar motion of the drone needs to be controlled. This is important so that the drone does not fly uncontrollably across the room while you're trying to tune its altitude controller. To control the drone's planar motion while you're tuning the altitude, we've created and tuned PIDs to do this for you, but you will need to tune the initial low-rate integral terms to account for the uneven weight distribution specific to your drone. You will first use the provided altitude PID to tune the planar controllers, and then you will tune your altitude PID with the tuned planar controllers.

Write brief answers to all exercises in <i>answers_pid.md</i>.

## Problem 1: Understanding the Controller
Our controller is a dual I-term (integral term) PID controller. The high-rate I-term changes quickly, allowing fast response to changes. The low-rate I-term changes slowly, allowing the drone to adjust to systemic sources of error. The provided PID gains have been pretuned to this drone hardware, and should not need significant modification for your specific drone. But, the initial low I-terms do need to be adjusted based on the static error of your specific drone.  

**Exercises**  
  1. Name a source of static error that the low-rate I term can correct for.  
  2. Name two sources of dynamic error that the high-rate I term can correct for.  

## Problem 2: Tune the Throttle
The first step in the tuning process is finding an initial throttle value that allows your drone to have a smooth and controlled takeoff. To do this, you'll be adjusting the value of `throttle_low.init_i` in <i>pid_class.py</i>. This is the initial value of the low-rate (slow changing) integral term for the throttle, which controls altitude. The default value is 100. you will tune this value by having the drone take off, observing its behavior, and modifying the value accordingly. Each time you wish to change the value, you will need to restart <i>pid_controller.py</i> to use the new value.  

**Setup**  
1. Prepare your drone to fly over a highly textured planar surface<sup id="a3">[1](#f3)</sup>.  
2. Navigate to \`4 of the screen.  
3. Quit the program by pressing ctrl-c.  
**Exercises**  
  1. In this screen (\`4), use a text editor (such as vim or nano) to modify `throttle_low.init_i` in <i>pid_class.py</i> to test out different values for `throttle_low.init_i`. Be cautious when modifying this value because the drone could take off abruptly with a value that is too high. The specific `throttle_low.init_i` value is drone specific, but typical values range between 50 and 150. Try both of these values and two more values between then. In one sentence, describe the drone's behavior as a result of changing the value up and down.  
  2. Now find the value for which your drone is able to have a smooth and controlled takeoff. The goal is to reduce the overshoot and undershoot for the drone to takeoff and fly stable at 0.3m. Try changing this value in increments of 10 and then 5 until you find a  value that allows the drone to take off at a reasonable rate. Record this value in your answers.  

## Problem 3: Set the Trim
Next you will set the trim on roll and pitch. You will do this by tuning the low I-terms to adjust for the static errors that exist on your drone. The default value is 0, and positive values will move the drone to the right or forward, and negative to the left or backward, depending on the axis you're modifying. Note that you may need to repeat this process periodically, for example after a crash or the like.
When performing this process, each time make sure that you:  

  * Place the battery in the same place each time as much as possible so the weight is distributed the same.  
  * Plug the flight controller while the struts are fully engaged and the drone is level, so the gyros are well calibrated.  
  * Always place the drone so that the camera is closer to you and the skyline is farther away.  

**Setup**  
Modify <i>pid_controller.py</i> to print out the low rate integral terms of the PIDs by finding the block of code shown below and uncommenting the following print statements

```
print 'roll_low.init_i', pid_controller.pid.roll_low.init_i
print 'pitch_low.init_i', pid_controller.pid.pitch_low.init_i
```

You will also need to set the `verbose` variable in this file to zero so that these print statements will not be overridden by the other print statements: `verbose = 0`

While flying, the low-rate I-terms will change to account for the static flight error, and when you disarm the drone, the initial low-rate I terms will be set to these changed values, thus allowing the low-rate I terms to start at this corrected value. Eventually, these values will converge, and your drone will no longer drift. Once converged, you will save the values by modifying the variables `self.roll_low.init_i` and `self.pitch_low.init_i` in `pid_class.py` to the corresponding value printed in \`4 of the screen after disarming. This will store the initial low-rate I-terms between flights.  

**Exercises**  

  1. Perform one flight. After the drone takes off, do not give it movement commands but allow it to drift.  
  2. Disarm the drone before it flies too far in any direction.  
  3. Write down the low-I values printed in \`4 of the screen.  
  4. Pick up and move the drone by hand back to the center of the flying area.  
  5. Repeat steps 1-4 until the values that are printed out after disarming have converged (roughly when the change in magnitude is less than 1).  
  6. Once these values have converged, record these values in your answers.  

###### Footnotes
[<b id="f3">1</b>](#a3)A flat posterboard scribbled or written on with marker will work. 

### Tuning 1D Controls: Part 2: Altitude Tuning 

In this part, you will be transferring the altitude PID you created in part 1 onto your drone. You will then tune the PID gains on your drone as you did in the simulator.

## Problem 1: Flying with Your Altitude PID!
Now that the planar PIDs are tuned, and you have found a value for `throttle_low.init_i` that allows the drone to take off at a reasonable rate, you will be using your altitude PID to control the height of the drone. To tune your altitude PID, you will first use the Ziegler-Nichols tuning method to generate an initial set of tuning parameters. You will then fine tune these parameters similar to how you tuned the drone in simulation.

 To use your PID, you'll be running <i>student_pid_controller.py</i> instead of <i>pid_controller.py</i>. This will allow your PID to run alongside our planar PIDs, and on top of our throttle low-rate I-term which you found previously. Your PID will be responsible for keeping the drone flying steady vertically.  

**Setup**  
Change directories to `~/ws/src`. Run `git clone https://github.com/h2r/project-pid-yourGithubName.git`. In your repo, change "<name>pidrone_project3_pid</name>" to "<name>project-pid-yourGithubName</name>" in _package.xml_ and "project(pidrone_project3_pid)" to "project(project-pid-yourGithubName)" in _CMakeLists.txt_. Also remove the msg folder, and comment out "add_message_files" in _CMakeLists.txt_. Then change directories back to `~/ws/` and run `catkin_make --pkg project-pid-yourGitHubName`.

_OR_

Use the `scp` command to transfer <i>student_pid_class.py</i>, <i>student_pid_controller.py</i>, and <i>z_pid.yaml</i> from the repo on your base station to the scripts folder of your drone (`~/ws/src/pidrone_pkg/scripts/`). In the instructions below, instead of using `rosrun`, you may use `python` to execute your scripts.

Change directories into `~/ws/src/pidrone_pkg` and modify _pi.screenrc_ to start up with your altitude pid by changing `python pid_controller.py\n` to `rosrun project-pid-yourGitHubName student_pid_controller.py\n`. Prepare your drone to fly and then navigate to \`4 of the screen. Press ctrl-c to quit student_pid_controller.

In this screen (\`4), modify `~/ws/src/project-pid-yourGitHubName/z_pid.yaml` by setting $K$ to 1250 and the rest of the gain constants to 0. Now run `rosrun project-pid-yourGitHubName student_pid_controller.py` to fly with your altitude PID.  

**Exercises**  

Fly your drone and observe its flight. Tune $K_p$ by slowly increasing its value between flights until you can see the drone moving up and down with uniform oscillations. Each time you will need to quit the controller, edit `~/ws/src/project-pid-yourGitHubName/z_pid.yaml`, and then run `rosrun project-pid-yourGitHubName student_pid_controller.py` again to use the new PID gains.  

  1. Record your final $K_p$ value that causes uniform oscillations as $K_u$, the ultimate gain.  
  2. Fly your drone and pause the altitude graph on the web interface when you see two peaks. Find the time difference between these two peaks and record this value as $T_u$, the ultimate period.  
  3. Use your $K_u$ and $T_u$ values to compute $K_p$, $K_i$, and $K_d$. Refer to the equations in the Ziegler-Nichols section in the introduction to this project. Record these values and change <i>z_pid.yaml</i> accordingly.  
  4. Fly your drone with the set of tuning values generated by the Ziegler-Nichols method. Note that the Ziegler-Nichols method should enable safe flight, but will probably not control your drone's altitude very well! Empirically tune the gain constants in <i>z_pid.yaml</i> on your drone as you did in the simulator portion of this project. <sup id="a6">[2](#f6)</sup> Record your final tuning values.  

Take a video of your drone flying first using our altitude pid by running <i>pid_controller.py</i> in \`4, then take a video of your tuned pid by running <i>student_pid_controller.py</i> in \`4. See if you can get yours to track the altitude setpoint better than ours! The drone should get to the setpoint quickly and stay there without bouncing up and down.

###### Footnotes
[<b id="f6">2</b>](#a6) Use the graph on the web interface to observe the drone's behavior as it oscillates around the 0.3m setpoint the drone's ability to hover at the setpoint. When observing the drone itself, try to get eye-level with the drone to just focus on the the altitude and ignore the planar motion; it is easier to focus on one axis at a time when tuning the PIDs. The planar axes can be re-tuned after you tune your altitude pid if need be.

### Tuning 1D Controls: Part 3: Position Control

Thus far, the planar PIDs have been used to control the velocity of the drone; now, you will use cascaded PIDs to control the position of the drone. The cascaded PIDs are set up so that the position controller forms the outer loop which uses the position error to provide setpoint velocities for the inner loop velocity controller.

### How to Engage Position Control
Engaging position control involves two steps. First you have to tell the drone to “remember” a frame. You can do this using the _r_ key. This will save the frame which the drone will attempt to fly directly above. Next you have to engage position control. You can engage this mode with the _p_ key, and disengage with _v_ for velocity control. So the procedure is to first save a frame (target location for position hold) using _r_ and then shortly after (before drifting too much) type _p_.

**Note:** Position hold works best over a textured surface with lots of visual contrast. Even when doing position hold, always be ready to kill in case of a mishap. Especially be careful when looking at other windows.

### Position Control Demo
This [video](https://www.youtube.com/embed/WTohnsKs7dU) demonstrates the drone doing a zero velocity hover and drifting in the scene. Then we turn on position hold (you can tell when it is engaged when the drone's throttle drops) and it holds its position for several minutes.

Then we turn off the position hold so you can see it drift again, and then turn it on again at the end and land. You can tell when it is turned on because we move the drone back to the center of the flight area before each hold.

## Problem 1: Flying with Velocity Control
First, you are going to experiment with flying your drone in velocity control and controlling its motion with the keyboard keys. Based on observations and knowledge of the controllers, you will then explain the inner workings of the velocity PIDs in your own words.  

**Setup**  
Prepare your drone to fly over a highly textured planar surface. Make sure there is space for the drone to fly around.  
**Exercise**  
Fly your drone in velocity control (the default control) and make sure there is room to fly to the right. Press and hold 'L' and observe the drone's motion, and release 'L' to stop the drone from moving.  

1. Explain what the following key terms are in this controller, and how they change to cause the drone to move when you press 'L' and stop when you release: setpoint, error, control variable, process variable, proportional term, integral term, derivative term. We are looking only for a higher level description to demonstrate understanding of the PID controllers.  
2. Try flying in velocity mode over a blank white poster board. Be careful! What do you notice about the drone's behavior, and what do you suspect causes this?  


## Problem 2: Flying with Position Control
Now you are going to fly your drone in position control and experiment with controlling its motion with the keyboard keys. Based on observations and knowledge of the controllers, you will then explain the inner workings of the position PIDs in your own words.  
**Setup**  
Prepare your drone to fly over a highly textured planar surface. Make sure there is space for the drone to fly around.  
**Exercises**  
1. Engage position hold using the procedure described above. Observe the drone's behavior. How is it different from just velocity control?  
2. How long are you able to hold position? Ideally you should be able to do this in one spot for an entire battery. If not, try re-tuning your I-term preloads above. If you're flying on the power supply instead of a battery, the drone should stay in place indefinitely, but you can stop it after 5 minutes.  
3. While flying in position control, make sure there is room for the drone to fly to the right and then take note of the desired position in \`4 of the screen. Now press the 'L' key in the user interface and note the new desired x-position of the drone; it should be 0.1m to the right of the drone's last position. Explain what the following key terms are in the outer loop position controller, and how they change to cause the drone to move and stop 0.1m to the right after you press 'L' in position control: setpoint, error, control variable, process variable, proportional term, integral term, derivative term. We are looking only for a higher level description to demonstrate understanding of cascaded PID controllers.  
4. Try flying in position control over a uniform surface such as the floor in 121, or un-patterned carpet. Echo the state of the drone by typing `rostopic echo /pidrone/state` into an empty window in the screen. Note the position data, and explain your observations of how well the drone is able to estimate its position. How long is it able to hold position? Does the drone move correctly when you use the arrow keys?

Take a one minute video of your drone flying in velocity control, and then engage position control. 